#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//回去复习整型提升
//C语言--> C++研发方向 -->C语言实现简单数据结构-->C++-->穿插高阶数据结构-->Linux系统编程 网络编程  数据库 实战项目
//JAVA / 测试开发方向-->JAVASE->实现简单数据结构-->JAVAweb(操作系统+网络）->JAVAEE->穿插讲数据库-->实战项目
//                                                              -> 分流：测试课程（测试理论+测试工具） 实战项目
///简历中必定要写项目，项目也是必问的，所以一定要重视
///总共12-14个月学完一个方向
//不管学哪个方向都是逃不过C的
//课程开始
//编译时常见的错误
//
// 1.编译性错误: 语法错误
// 缺少括号 分号 
// 2.链接型错误
// 我们生成test.c文件源文件--------------->test.exe可执行程序
//                       编译      链接
// 比如说我们要完成一个加法操作
////int add(int x, int y)
////{
////	return x + y;
////}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = add(a, b);
//	printf("%d", c);
//	return 0;
//}
//错误	LNK2019	无法解析的外部符号 _add，函数 _main 中引用了该符号	
// 这就是链接型错误，变量名写错啥的情况
// 这里我们如果点击错误符号，无法跳转到错误的行上面，我们可以通过Ctrl+F查找这个变量名进行定位
// 手动排查才能找到错误
// 如果是别人使用的，那么就很难找了
// 
// 3.运行时错误： 有bug了，借助调试去解决的错误
// 运行过程中的错误，不是前两种那种肉眼可见的，是真正需要去排查的
// 
// github访问很有障碍，所以我们就使用gitee，而且是中文的，一定要尝试起来
// 我写的代码还是挺挫的，我们现在是坚持写代码，万一别人看到也无所谓，我们就把这些东西记录下来
// 我们坚持坚持，慢慢来，慢慢来
// 贴一份满绿的链接哈哈哈哈哈哈哈哈哈哈哈哈冲冲冲冲冲
//C语言初阶的内容学完了
// 我丢我丢我丢
// 
// 进阶第一颗
// 数据类型详细介绍
// 整形在内存中的存储： 原码 反码 补码
// ....
// 
// 1数据类型介绍：
// 前面我们已经学习了基本的内置类型
// char short int long longlong float double
// 字符数据型短整型整型长整型更长的整型单精度浮点数双精度浮点数
// 有了丰富的类型我们可以更加灵活的使用
// 类型的意义：
// 使用这个类型开辟内存空间的大小
// 如何看待内存空间的视角
// 
// 1.1类型的基本归类：
// 整型家族： 
// char  unsigned char   signed char  
// char 类型虽然是字符类型，但是字符类型存储的时候，存储的字符的ascii码值
// ascii值是整数,所以char类型是整型
// 
// short unsinged short[int]  signed short[int]   
//       无符号的短整型          有符号的短整型
// short s1;//有符号的
// 相等于 signed short s2;//有符号的
// 我们如果想表示有正负的数据例如温度，可以粗放在有符号的变量中
// 年龄：只有正数的数据 可以存放在无符号的变量当中
// 有符号，无符号那么该如何理解？
// short -2个byte--16bit
// 0000000000000000
// 一个二进制序列 ： 如果是有符号的数据，最高位是符号位
// 最高位是0，表示正数
// 最高位是1，表示负数
// 对于无符号数来说，最高位也是数据位
// int 类型 int相当于signed int 
// unsigned int 需要单独说明
// long 类型 long相当于signed long 
// char类型比较特殊，C语言没有规定char 是signed char 还是unsigned char
// 这个完全取决于编译器，大部分char 还是signed char
// 那么我们梳理完之后
// 开始
// 
// 浮点型家族：
// float
// double
// 当然也还有long double 这种类型
// 
// 构造类型家族（自定义类型）
// 数组类型 int [x]；x可以自定义
// int 也是任意的，可以改成其他类型char short..
// 结构体类型struct
// 枚举类型enum
// 联合类型union
// 
// 指针类型家族:
// 指针变量是用来存放地址的
// 当然呢，不同的指针类型代表的意义也有所差异
// 
// 空类型/无类型：
// void （空）
//void test（void)//（void)意思不需要传参
//{
//	；
//}
//
// 整型在内存中的存储：
//  原码反码补码：
//int main()
//{
//	//整数可以写出三种2进制的表示形式
//	int a = 10;//整型值
//	//原码：直接翻译成2进制数
//	//000000000000000000000000000001010
//	//正数整型的反码和原码一样
//	//000000000000000000000000000001010
//	//正数整形的补码和原码一样
//	//000000000000000000000000000001010
//	int b = -10;//整型值
//	//负数的表示方式不同
//	//原码
//	//10000000000000000000000000001010
//	//反码：符号位不变，其他位按位取反
//	//11111111111111111111111111110101
//	//补码:反码+1
//	//11111111111111111111111111110110
//	// 
//	//内存中存放的都是补码
//	//   1111 1111 1111 1111 1111 1111 1111 0110
//	//0x F      F   F     F    F    F   F     6
//	//0xFFFFFFF6
//	//我看了是一样的，不是摆拍，要倒着看4位（从右往左看每1位），顺着（从左往右）读2个数
//	//
//	return 0;
//}
// 2进制
// 8进制
// 10进制
// 16进制
// 不同的进制，只是数据的表示形式：
// 数字：
// 50-10进制
// 对应
// 32-16进制
// 对应
// 62-8进制
// 进制说明：
// 2进制 0~1
// 8进制 0~7
// 10进制0~9
// 16进制0~9 a~f
// 
// 为什么数据在内存中存储的是补码？
// 
// 举个例子
//int main()
//{
	//计算1-1
	//CPU只会加法
	//1-1=1+（-1）；
//00000000000000000000000000000001 原码
//10000000000000000000000000000001 原码
//10000000000000000000000000000010 用原码计算是错误的
//使用补码的方式：
//00000000000000000000000000000001 原码
//11111111111111111111111111111111 补码（反码+1）
//100000000000000000000000000000000  最前面那个1 放不下了，然后就是0啦
//00000000000000000000000000000000  实际情况，丢高位，留低位
	//return 0;
//}
//假设我们是char字节
// 1byte  8bit
// 00000000
// ~
// 01111111  127最大正值
// ~
// 10000000   直接解析为-128
// ~
// 11111110-->10000010 原码 值为-2
// 11111111-->10000001 原码 值为-1
// 那么signed char 的值的取值范围就已知了，是-128~127
// 如果是unsigned char  0~255  256个数字！
//int main()
//{
//
//	unsigned int ch = -10;
//	printf("%u\n", ch);//%u打印无符号数，不是无符号数，也认为是无符号数
//	printf("%d\n", ch);//打印有符号数，不是有符号，也认为是有符号
//	return 0;
////100000000000000000000000000000001010
////111111111111111111111111111111110101
////111111111111111111111111111111110110 补码形式 因为无符号 结果为一个正数
//}
// short数据类型
// short --signed short
// 2byte
// 16bit
//0000000000000000
// ~
//0111111111111111  32767
//1000000000000000   直接被解析为-32768
// ~
//1111111111111110    -2
//1111111111111111    -1
// 
// 如果是unsigned short
//0000000000000000  0
// ~
//1111111111111111  65535
// 
//int main()
//{
//	int a = 0x11223344;
//	//通过调试后
//	//窗口 内存查看存放的数据
//	//可以看到是倒着放的
//	return 0;
//}
///////新知识点： 大小端字节序存储
// 大端字节序存储
// 小端字节序存储
//大端字节序存储：  把一个数据的低位字节处的数据存放在高地址处
//                 把高位字节处的数据存放在低地址处
// 小端字节序存储： 把一个数据的地位字节处的数据存放在低地址处
//                 把高位字节处于的数据存放在高地址处
//	VS使用的是小端
// 出现这个东西的原因:
//在计算机系统中，我们以字节为单位， 每个地址单元都对应着一个字节，一个字节为8bit
// 对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节
// 那么必然存在着一个如何将多个字节安排的问题。
// 因此就出现了大端存储和小端存储模式的区别。
//int check(int a)
//{
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//		return 0;
//}
//int main()
//{
//	int a = 1;
////00000000000000000000000000000001
//	//0x 00 00 00 01
//	//大端存储
//	//0x 01 00 00 00
//	//小端存储
//	int ret=check(a);
//	printf("%d\n", ret);
//	return 0;
//}
// 
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("%d %d %d", a, b, c);//用char打印整型会进行整型提升我丢！！！！
//	//打印的是有符号数，提升后再求原码（-1取反）
//	//unsigned char 无符号位整型提升直接补0 
////00000000000000000000000011111111  255
//	return 0;
//}
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//






















































#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//回去复习整型提升
//C语言--> C++研发方向 -->C语言实现简单数据结构-->C++-->穿插高阶数据结构-->Linux系统编程 网络编程  数据库 实战项目
//JAVA / 测试开发方向-->JAVASE->实现简单数据结构-->JAVAweb(操作系统+网络）->JAVAEE->穿插讲数据库-->实战项目
//                                                              -> 分流：测试课程（测试理论+测试工具） 实战项目
///简历中必定要写项目，项目也是必问的，所以一定要重视
///总共12-14个月学完一个方向
//不管学哪个方向都是逃不过C的
//课程开始
//编译时常见的错误
//
// 1.编译性错误: 语法错误
// 缺少括号 分号 
// 2.链接型错误
// 我们生成test.c文件源文件--------------->test.exe可执行程序
//                       编译      链接
// 比如说我们要完成一个加法操作
////int add(int x, int y)
////{
////	return x + y;
////}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = add(a, b);
//	printf("%d", c);
//	return 0;
//}
//错误	LNK2019	无法解析的外部符号 _add，函数 _main 中引用了该符号	
// 这就是链接型错误，变量名写错啥的情况
// 这里我们如果点击错误符号，无法跳转到错误的行上面，我们可以通过Ctrl+F查找这个变量名进行定位
// 手动排查才能找到错误
// 如果是别人使用的，那么就很难找了
// 
// 3.运行时错误： 有bug了，借助调试去解决的错误
// 运行过程中的错误，不是前两种那种肉眼可见的，是真正需要去排查的
// 
// github访问很有障碍，所以我们就使用gitee，而且是中文的，一定要尝试起来
// 我写的代码还是挺挫的，我们现在是坚持写代码，万一别人看到也无所谓，我们就把这些东西记录下来
// 我们坚持坚持，慢慢来，慢慢来
// 贴一份满绿的链接哈哈哈哈哈哈哈哈哈哈哈哈冲冲冲冲冲
//C语言初阶的内容学完了
// 我丢我丢我丢
// 
// 进阶第一颗
// 数据类型详细介绍
// 整形在内存中的存储： 原码 反码 补码
// ....
// 
// 1数据类型介绍：
// 前面我们已经学习了基本的内置类型
// char short int long longlong float double
// 字符数据型短整型整型长整型更长的整型单精度浮点数双精度浮点数
// 有了丰富的类型我们可以更加灵活的使用
// 类型的意义：
// 使用这个类型开辟内存空间的大小
// 如何看待内存空间的视角
// 
// 1.1类型的基本归类：
// 整型家族： 
// char  unsigned char   signed char  
// char 类型虽然是字符类型，但是字符类型存储的时候，存储的字符的ascii码值
// ascii值是整数,所以char类型是整型
// 
// short unsinged short[int]  signed short[int]   
//       无符号的短整型          有符号的短整型
// short s1;//有符号的
// 相等于 signed short s2;//有符号的
// 我们如果想表示有正负的数据例如温度，可以粗放在有符号的变量中
// 年龄：只有正数的数据 可以存放在无符号的变量当中
// 有符号，无符号那么该如何理解？
// short -2个byte--16bit
// 0000000000000000
// 一个二进制序列 ： 如果是有符号的数据，最高位是符号位
// 最高位是0，表示正数
// 最高位是1，表示负数
// 对于无符号数来说，最高位也是数据位
// int 类型 int相当于signed int 
// unsigned int 需要单独说明
// long 类型 long相当于signed long 
// char类型比较特殊，C语言没有规定char 是signed char 还是unsigned char
// 这个完全取决于编译器，大部分char 还是signed char
// 那么我们梳理完之后
// 开始
// 
// 浮点型家族：
// float
// double
// 当然也还有long double 这种类型
// 
// 构造类型家族（自定义类型）
// 数组类型 int [x]；x可以自定义
// int 也是任意的，可以改成其他类型char short..
// 结构体类型struct
// 枚举类型enum
// 联合类型union
// 
// 指针类型家族:
// 指针变量是用来存放地址的
// 当然呢，不同的指针类型代表的意义也有所差异
// 
// 空类型/无类型：
// void （空）
//void test（void)//（void)意思不需要传参
//{
//	；
//}
//
// 整型在内存中的存储：
//  原码反码补码：
//int main()
//{
//	//整数可以写出三种2进制的表示形式
//	int a = 10;//整型值
//	//原码：直接翻译成2进制数
//	//000000000000000000000000000001010
//	//正数整型的反码和原码一样
//	//000000000000000000000000000001010
//	//正数整形的补码和原码一样
//	//000000000000000000000000000001010
//	int b = -10;//整型值
//	//负数的表示方式不同
//	//原码
//	//10000000000000000000000000001010
//	//反码：符号位不变，其他位按位取反
//	//11111111111111111111111111110101
//	//补码:反码+1
//	//11111111111111111111111111110110
//	// 
//	//内存中存放的都是补码
//	//   1111 1111 1111 1111 1111 1111 1111 0110
//	//0x F      F   F     F    F    F   F     6
//	//0xFFFFFFF6
//	//我看了是一样的，不是摆拍，要倒着看4位（从右往左看每1位），顺着（从左往右）读2个数
//	//
//	return 0;
//}
// 2进制
// 8进制
// 10进制
// 16进制
// 不同的进制，只是数据的表示形式：
// 数字：
// 50-10进制
// 对应
// 32-16进制
// 对应
// 62-8进制
// 进制说明：
// 2进制 0~1
// 8进制 0~7
// 10进制0~9
// 16进制0~9 a~f
// 
// 为什么数据在内存中存储的是补码？
// 
// 举个例子
//int main()
//{
	//计算1-1
	//CPU只会加法
	//1-1=1+（-1）；
//00000000000000000000000000000001 原码
//10000000000000000000000000000001 原码
//10000000000000000000000000000010 用原码计算是错误的
//使用补码的方式：
//00000000000000000000000000000001 原码
//11111111111111111111111111111111 补码（反码+1）
//100000000000000000000000000000000  最前面那个1 放不下了，然后就是0啦
//00000000000000000000000000000000  实际情况，丢高位，留低位
	//return 0;
//}
//假设我们是char字节
// 1byte  8bit
// 00000000
// ~
// 01111111  127最大正值
// ~
// 10000000   直接解析为-128
// ~
// 11111110-->10000010 原码 值为-2
// 11111111-->10000001 原码 值为-1
// 那么signed char 的值的取值范围就已知了，是-128~127
// 如果是unsigned char  0~255  256个数字！
//int main()
//{
//
//	unsigned int ch = -10;
//	printf("%u\n", ch);//%u打印无符号数，不是无符号数，也认为是无符号数
//	printf("%d\n", ch);//打印有符号数，不是有符号，也认为是有符号
//	return 0;
////100000000000000000000000000000001010
////111111111111111111111111111111110101
////111111111111111111111111111111110110 补码形式 因为无符号 结果为一个正数
//}
// short数据类型
// short --signed short
// 2byte
// 16bit
//0000000000000000
// ~
//0111111111111111  32767
//1000000000000000   直接被解析为-32768
// ~
//1111111111111110    -2
//1111111111111111    -1
// 
// 如果是unsigned short
//0000000000000000  0
// ~
//1111111111111111  65535
// 
//int main()
//{
//	int a = 0x11223344;
//	//通过调试后
//	//窗口 内存查看存放的数据
//	//可以看到是倒着放的
//	return 0;
//}
///////新知识点： 大小端字节序存储
// 大端字节序存储
// 小端字节序存储
//大端字节序存储：  把一个数据的低位字节处的数据存放在高地址处
//                 把高位字节处的数据存放在低地址处
// 小端字节序存储： 把一个数据的地位字节处的数据存放在低地址处
//                 把高位字节处于的数据存放在高地址处
//	VS使用的是小端
// 出现这个东西的原因:
//在计算机系统中，我们以字节为单位， 每个地址单元都对应着一个字节，一个字节为8bit
// 对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节
// 那么必然存在着一个如何将多个字节安排的问题。
// 因此就出现了大端存储和小端存储模式的区别。
//int check(int a)
//{
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//		return 0;
//}
//int main()
//{
//	int a = 1;
////00000000000000000000000000000001
//	//0x 00 00 00 01
//	//大端存储
//	//0x 01 00 00 00
//	//小端存储
//	int ret=check(a);
//	printf("%d\n", ret);
//	return 0;
//}
// 
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("%d %d %d", a, b, c);//用char打印整型会进行整型提升我丢！！！！
//	//打印的是有符号数，提升后再求原码（-1取反）
//	//unsigned char 无符号位整型提升直接补0 
////00000000000000000000000011111111  255
//	return 0;
//}
// 杨辉三角，自己写废了
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int k = 0;
//	for(k=1;k<n;k++)
//	{
//		
//			printf("%d ",i);
//		printf("\n");
//	}
//	return 0;
//}
//int main()
//{
//	int a[9][9] = { 0 };
//	int i, j;
//	int n = 0;
//	scanf("%d", &n);
//	for (i = 0; i < n; i++)
//	{
//		a[i][0] = 1;
//		//for (j = 1; j < n; j++)
//		//{
//		//	a[i][j] = 0;
//		//}
//	}
//	for (i = 1; i < n; i++)
//	{
//		for (j = 1; j <=i; j++)
//		{
//			a[i][j] = a[i - 1][j] + a[i - 1][j - 1];
//		}
//	}
//	for (i = 0; i < n; i++)
//	{
//		for (j = 0; j <=i; j++)
//		{
//			printf("%d ", a[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}
//int main()
//{
//	char a = 0;
//	char b = 'C';
//	char c = 'D';
//	char d=
//	return 0;
//}
//int main()
//{
//	int killer = 0;
//	for (killer = 'a'; killer <= 'd'; killer++)
//	{
//		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
//		{
//			printf("凶手是：%c", killer);
//		}
//	}
//	return 0;
//}
//int check(int* p)
//{
//	int tmp
//}
//int main()
//{
//	return 0;
//}
// 
// 
// 
//
//int checkData(int* p)//查重函数 666
//{
//	int tmp[7] = { 0 }; //标记表，实际是哈希表的思路。一开始每个元素都是0。
//
//	int i;
//	for (i = 0; i < 5; i++)
//	{
//		if (tmp[p[i]]) //如果这个位置的标记已经是1，则代表重复，直接返回0。
//		{
//			return 0;
//		}
//		tmp[p[i]] = 1; //如果不是，则给这个位置标记为1。
//	}
//	return 1; //全部标记完毕也没有出现重复的情况，代表OK。
//}
//
//int main()
//{
//	int p[5]; //0 1 2 3 4分别代表a b c d e
//	//开始循环，一层一层的遍历开始猜，逻辑比较简单，一个一个试试 可以理解。
//	for (p[0] = 1; p[0] <= 5; p[0]++)
//	{
//		for (p[1] = 1; p[1] <= 5; p[1]++)
//		{
//			for (p[2] = 1; p[2] <= 5; p[2]++)
//			{
//				for (p[3] = 1; p[3] <= 5; p[3]++)
//				{
//					for (p[4] = 1; p[4] <= 5; p[4]++) //五层循环遍历
//					{
//						//这里是五个人的描述，、
//						//由于比较表达式只有0和1两个结果，如果要两个条件有且只有一个为真
//						//则可以用比较表达式的值总和为1的方式直接判定。别忘了还要判定不能并列。
//						if ((p[1] == 2) + (p[0] == 3) == 1 && //B第二，我第三
//							(p[1] == 2) + (p[4] == 4) == 1 && //我第二，E第四
//							(p[2] == 1) + (p[3] == 2) == 1 && //我第一，D第二
//							(p[2] == 5) + (p[3] == 3) == 1 && //C最后，我第三
//							(p[4] == 4) + (p[0] == 1) == 1 && //我第四，A第一
//							checkData(p) //不能并列
//							)//条件成立后进行下一步的打印
//						{
//							for (int i = 0; i < 5; i++)
//							{
//								printf("%d ", p[i]);
//							}
//							putchar('\n');
//						}
//					}
//				}
//			}
//		}
//	}
//
//	return 0;
//}
//
//
//※之后为扩展了解内容。
//
//
//
//改进一：
//
//
//
//检查是否重复的过程，我们是用一个数组来做的，实际每个标签只有0和1两种可能，没必要一定要用数组做，可以考虑用一个位来做（哈希中的位图），代码如下：
//
//
//
//
//
int checkData(int* p)
{
	char tmp = 0;//00000000

	int i;
	for (i = 0; i < 5; i++)
	{
		tmp |= 1 << p[i];//按位或 
						 //左移操作符
						 // 名次按顺序总共为12345
						 // 
		//tmp每次或上一位1，p[i]如果是1~5都有，则1<<1到1<<5都或上的结果将会是00111110，如果有并列，则一定会至少却其中一个1，结果就不会是00111110，所以可以判断tmp最终的结果是不是这个数字来判断有没有重复。
	}
	return tmp == 0x3E;//00111110
}
//
//
//
//
//改进二：
//
//
//
//循环代码又长又难看，可以考虑改成递归：
//
//
//
//
//
//void diveRank(int* p, int n)
//{
//	if (n >= 5) //此时的n是用来控制循环层数的。
//	{
//		if ((p[1] == 2) + (p[0] == 3) == 1 && //B第二，我第三
//			(p[1] == 2) + (p[4] == 4) == 1 && //我第二，E第四
//			(p[2] == 1) + (p[3] == 2) == 1 && //我第一，D第二
//			(p[2] == 5) + (p[3] == 3) == 1 && //C最后，我第三
//			(p[4] == 4) + (p[0] == 1) == 1 && //我第四，A第一
//			checkData(p)) //查重
//		{
//			for (int i = 0; i < 5; i++)
//			{
//				printf("%d ", p[i]);
//			}
//			putchar('\n');
//		}
//		return;
//	}
//
//	for (p[n] = 1; p[n] <= 5; p[n]++)
//	{
//		diveRank(p, n + 1); //通过递归模拟多层循环，每进一次递归相当于进了一层新的循环。
//	}
//}
//
//int main()
//{
//	int p[5];
//
//	diveRank(p, 0);
//
//	return 0;
//}
////
//
//
//
//改进三：
//
//
//
//以上的方法只是让代码简单了点，但还是需要5 ^ 5次比较，而如果本来就是做1~5的排列组合的话只需要5!次比较，能极大的减少遍历所需的次数（复杂度由O(n ^ n)降低为O(n!)），那是不是可以用一个递归完成对1~5的全排列呢？当然是可以的，所以我们可以进一步优化遍历的方式，将遍历用的递归程序改成这样：
//
//
//
#include <stdio.h>

void swapArgs(int* a, int* b) //交换函数
{
	int tmp;

	tmp = *a;
	*a = *b;
	*b = tmp;
}

void diveRank(int* p, int n)
{
	if (n >= 5) //此时的n也是用来控制循环层数的。
	{
		if ((p[1] == 2) + (p[0] == 3) == 1 && //B第二，我第三
			(p[1] == 2) + (p[4] == 4) == 1 && //我第二，E第四
			(p[2] == 1) + (p[3] == 2) == 1 && //我第一，D第二
			(p[2] == 5) + (p[3] == 3) == 1 && //C最后，我第三
			(p[4] == 4) + (p[0] == 1) == 1)   //我第四，A第一
			//由于此时是执行的全排列，所以查重也省了。
		{
			for (int i = 0; i < 5; i++)
			{
				printf("%d ", p[i]);
			}
			putchar('\n');
		}
		return;
	}

	int i;
	for (i = n; i < 5; i++) //这个递归方式就完成了对1~5的全排列，方法是从后向前不停的执行交换。可以参考改进二和原代码，将这个递归程序写回成循环后，可以更好的理解。
	{
		swapArgs(p + i, p + n);
		diveRank(p, n + 1);
		swapArgs(p + i, p + n);
	}
}

int main()
{
	int p[5] = { 1, 2, 3, 4, 5 }; //当然由于是全排列，所以初值必须给好。

	diveRank(p, 0);

	return 0;
}
//
//
//至此，遍历速度上达到了一个新的高度，这种遍历大大减少了遍历的次数，极大的提升了效率。
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//
// 
// 
// 
// 
// 
// qingjiayitian
//






















































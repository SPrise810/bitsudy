#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//
//讲解调试案例
// 
// 
// 
// 
// 
//1.实现代码：n的阶乘的和1!+2!+3!+4!+5!
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//求n的阶乘
//	//1~n的数字
//	int i = 0;
//	int ret = 0;
//	int sum = 0;
//	for (n = 1; n <= 10; n++)
//	{
//		for (i = 1; i <= n; i++)//求阶乘
//		{
//			ret *= i;
//		}
//		sum += ret;
//	}
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;
//		sum += ret;
//	}//简化版写法：  原理：2！*3=3！   3！*4 = 4！
//	printf("%d", sum);
//	//代码有问题
//	//1!+2!+3!=9,运行中结果为15
//	//我们开始找问题
//	//调试！
//	// 	   
//	//我们通过监视窗口发现我们的ret在求3的阶乘的时候的值不对
//	//定位到问题后，我们了解到原来是对数字求阶乘的时候ret没有进行相应的初始化
//	return 0;
//}
////////////////小黄鸭调试法： 
//我们发现程序存在问题的时候可以通过
//假装有一只小黄鸭，它啥也不懂，然后我们试着给它 讲解这个程序的逻辑
//讲着讲着可能就发现了自己程序的问题所在
//
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", &i);
//	printf("%p\n", &arr[9]);
//	//debug环境里面
//	// 00B8FEC8     i  高地址
//	//00B8FEBC     arr[9]  低地址
//	// 
//	// 	   release环境下
//	// 	   release对程序优化，竟然连内存都优化了，我丢
//	//004FFD94  低地址  i
//	//004FFDBC  高地址  arr[9]
//	for (i = 0; i <= 12; i++)//越界+死循环
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	//	//我们通过调试，发现在内存当中，数组越界后访问到了i的内存，arr[12]竟然是i
//	//	//场景只是我们自己特地制作的，不同的编译器可能有不同的结果
//
//	}
//	return 0;
//}
///内存：  栈区  堆区  静态区
//栈区：  局部变量 函数形参
//堆区：  讲过
//静态区：  讲过
//讲栈区             ：  高地址 （上方）
                         //。。
//                      低地址  （下方）
//栈区的使用习惯： 先使用高地址的空间，在使用低地址处的空间
//幸好看过函数栈帧的创建和销毁嘿嘿
//图片：16节调试70行.png
		//上面巧妙东阿代码非常依赖环境  
		// 举个例子：
		//VC6.0--98年软件  里i和arr数组中间没有空
		//gcc中i和arr数组中空出一个int空间
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (i = 0; i <= 12; i++)//越界+死循环
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}
//release里面 竟然能够运行成功 说这个也是为了说明不同环境下的不同情况
//出自于这本书--《C陷阱和缺陷》
//学好调试加油加油
// 
// F10+断点 在大的工程中经常使用
// 优秀的代码:
// 优秀的代码:// 优秀的代码:// 1.代码运行正常
// 2.bug很少
// 3.效率高
// 4.可读性高
// 5.可维护性高
// 6.注释清晰
// 7.文档齐全
// 常见的编程技巧： 常见的编程技巧：
// 使用assert
// 尽量使用const
// 养成良好的编程风格
// 添加必要的注释
// 避免编码的陷阱
// 
//示范:模拟实现库函数strcpy  字符串拷贝
//
// #include<string.h>
//void my_strcpy(char* arr2, char* arr1)
//{
//	while (*arr1!='\0')
//	{
//		*arr2 = *arr1;
//			arr1++;
//			arr2++;
//	}
//	//  \0还没有拿
//	*arr2 = *arr1;
//}
//int main()
//{
//	//写一个功能一摸一样的函数
//	char arr1[] = "hello bit";
//	char arr2[20] ="xxxxxxxxxxxxx";
//	//strcpy(arr2, arr1);//函数将\0也拷贝过去了 
//	my_strcpy(arr2, arr1);
//	printf("%s", arr2);
//	return 0;
//}
// 
////这样的代码如果满分10分，也就是5分的水平
//修改版1.0
void my_strcpy(char* arr2, char* arr1)
{
	while (*arr1!='\0')
	{
		*arr2++ = *arr1++;
	}
//修改版2.0
	void my_strcpy(char* arr2, char* arr1)
	{
		while (*arr2++ = *arr1++)
			//判断结果为字符的ASCII码值，不为假就运行空语句
			//还有顺便的++
		{
			;
		}
	}
	//7分水平
	// 
//修改版3.0
//如果我们的参数为空指针，野指针，那么就有问题
//如果万一是空指针，那么就嘎了
//assert引用头文件
#include<assert.h>
	void my_strcpy(char* arr2, char* arr1)
	{
		assert（arr2 != NULL);//断言
		assert（arr2 != NULL);//断言
		assert（arr2 &&arr1 != NULL);//断言

		//如果后面的表达式为假就报错，为真就不报错
		//而且报错的形式非常特别，它会在输出你在程序中哪一行的位置有问题（断言的位置）
		while (*arr2++ = *arr1++)
			//判断结果为字符的ASCII码值，不为假就运行空语句
			//还有顺便的++
		{
			;
		}
	}
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//
//
//
//






















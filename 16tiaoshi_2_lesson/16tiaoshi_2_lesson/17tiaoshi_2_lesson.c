#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//
//讲解调试案例
// 
// 
// 
// 
// 
//1.实现代码：n的阶乘的和1!+2!+3!+4!+5!
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//求n的阶乘
//	//1~n的数字
//	int i = 0;
//	int ret = 0;
//	int sum = 0;
//	for (n = 1; n <= 10; n++)
//	{
//		for (i = 1; i <= n; i++)//求阶乘
//		{
//			ret *= i;
//		}
//		sum += ret;
//	}
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;
//		sum += ret;
//	}//简化版写法：  原理：2！*3=3！   3！*4 = 4！
//	printf("%d", sum);
//	//代码有问题
//	//1!+2!+3!=9,运行中结果为15
//	//我们开始找问题
//	//调试！
//	// 	   
//	//我们通过监视窗口发现我们的ret在求3的阶乘的时候的值不对
//	//定位到问题后，我们了解到原来是对数字求阶乘的时候ret没有进行相应的初始化
//	return 0;
//}
////////////////小黄鸭调试法： 
//我们发现程序存在问题的时候可以通过
//假装有一只小黄鸭，它啥也不懂，然后我们试着给它 讲解这个程序的逻辑
//讲着讲着可能就发现了自己程序的问题所在
//
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", &i);
//	printf("%p\n", &arr[9]);
//	//debug环境里面
//	// 00B8FEC8     i  高地址
//	//00B8FEBC     arr[9]  低地址
//	// 
//	// 	   release环境下
//	// 	   release对程序优化，竟然连内存都优化了，我丢
//	//004FFD94  低地址  i
//	//004FFDBC  高地址  arr[9]
//	for (i = 0; i <= 12; i++)//越界+死循环
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	//	//我们通过调试，发现在内存当中，数组越界后访问到了i的内存，arr[12]竟然是i
//	//	//场景只是我们自己特地制作的，不同的编译器可能有不同的结果
//
//	}
//	return 0;
//}
///内存：  栈区  堆区  静态区
//栈区：  局部变量 函数形参
//堆区：  讲过
//静态区：  讲过
//讲栈区             ：  高地址 （上方）
                         //。。
//                      低地址  （下方）
//栈区的使用习惯： 先使用高地址的空间，在使用低地址处的空间
//幸好看过函数栈帧的创建和销毁嘿嘿
//图片：16节调试70行.png
		//上面巧妙东阿代码非常依赖环境  
		// 举个例子：
		//VC6.0--98年软件  里i和arr数组中间没有空
		//gcc中i和arr数组中空出一个int空间
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (i = 0; i <= 12; i++)//越界+死循环
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}
//release里面 竟然能够运行成功 说这个也是为了说明不同环境下的不同情况
//出自于这本书--《C陷阱和缺陷》
//学好调试加油加油
























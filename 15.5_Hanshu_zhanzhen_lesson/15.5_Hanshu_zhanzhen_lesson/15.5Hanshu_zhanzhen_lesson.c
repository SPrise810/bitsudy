#define CRT_SERCURE_NO_WARNINGS 1
#include<stdio.h>
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//前期我们学习可能有很多的困惑：
//局部变量是怎么创建的？
//为什么局部比那辆的值是随机值？
//函数是怎么传参的，传参的顺序是怎么样的？
//形参和实参是什么关系？
//函数调用是怎么做的 ？
//函数调用结束后是怎么返回的？
//
//知道了函数栈帧的创建和销毁都毁了，其实就是修炼了自己的内功，也能够搞懂后期更多的知识。
//因为高级的编译器封装的比较多，不容易学习和观察，所以课件演示的时候使用的是VS2013
//在不同的编译器下，函数调用过程中栈帧的创建是略有差异的，具体细节取决于编译器的实现
//每一个版本是略有差异的，所以VS2019可能无法一比一实现课件所展示的画面
//所以就大量截图把
//
// 
// 介绍一下寄存器：
//eax
//ebx
// ecx
// edx
// 下面两个寄存器中存放的是地址：
// ebp 
// esp  
//这两个寄存器是用来维护函数栈帧的
//什么意思： 每一个函数调用，都要在栈区上开创建一个空间
//
//举个例子：
//开始编写函数了就
int add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	c = add(a, b);
	printf("%d", c);
	return 0;
}
//调用堆栈开始后，首先main函数被调用
// 
//我们通过观察发现，main函数首先被一个__tmainCERStartup()这个函数调用
//main函数也是被调用的（需要知道）
//
// 在VS2013中，main函数也是被其他函数调用的
//这个其他函数又是被mainCRTStarup()函数调用的
// 图3
//为什么要讲这些东西呢
//我们回到这个栈帧
//这个栈底指针和栈顶指针都是为了维护其中的地址，再次重复一下，我们下面开始研究
// 图1图2
//然后我们开始进行F10调试，在main函数入口停止进入 反汇编，观察汇编代码
//这些代码该如何理解呢？
//跟着思路来，符号名不好看，我们去掉符号名称
// 图4
//调用main函数之前我们要调用__CRTStarup() 它的栈帧应该提前创建好了
// 图5.0
//___CRTStarup 应该有两个指针（栈底指针和栈顶指针）指向这个空间，esp和ebp目前的位置就是在这两个地方
// 当我们从下往上走的时候，前提是下面是高地址  往上是低地址
// 图6.1
//我们首先push ebp     (压栈：给栈放个元素进去）
// 我们发现esp指针的地址跑到了ebp空间的最上方
// 
// 出栈：给栈顶删除一个元素，压栈：给栈顶放置一个元素
// 
//紧接着move操作，
//ebp指针到了esp指针的位置
//然后sub操作  减法操作（esp-04sh【8进制数字：228】）
//这里esp就变小了，指向了上面的区域
//esp往上走了
//那么我们ebp和esp又有了新的维护的空间
//我们为main函数申请好的好了空间，即main函数的栈帧（紫色部分）
//我们观察esp的地址，发现main函数的空间嘎嘎大
// 紧接着我们看见三个push操作
// 这三个值不用关心，他们会自动弹出的
// 分别是ebx esi edi,每当我们push完了之后esp指针就会变，它往上走
// 然后我们进行了一个lea操作 ：load effecive address 加载有效地址
// 把这样后面有效的地址加到edi里面去 ：FFFFFFF1Ch(显示符号名后：ebp-0E4h)
// word 表示两个字节
// dword 表示两倍 就是 四个字节
// 我们要把edi指针（指向的内存） 这个位置开始向下的这么多个空间进行ecx次（值为39h)全部改成eax的内容：0CCCCCCCH
// 图5图6
// ebp-0e4h就是 ：0x008ffac0这个位置
//初始化到哪里呢：ebp(0x008ffba4)
//刚刚这个动作，我们就把所有内存的值（main函数范围）全部改为了CCC
//图7
// 现在为main函数开辟内存的准备工作就结束了
//接下来就是有效代码： int a=10;
//dword ptr [ebp-8],0Ah
//图8
//我们的烫烫烫就是这些CCCC这样的东西
//int b=20;
//dword ptr[ebp-14h],14h
//b的20就放进去了，这个放的位置取决于编译器
//int c=0;
//dword ptr[ebp-20h],0
//接下来调用add函数
//图9 看看有效代码图片
//函数调用进行传参
// move eax,dword ptr [ebp-14h](b=20)
//push eax-20 (压栈） 
//压栈前 ：图10 esp：0x008ffab4
//压栈后：  图11 esp:0x008ffab0
// 画图里多出了eax：20的空间
//然后对a下手
// move ecx,dword ptr [ebp-8]
//push ecx 
// 压栈后  ：esp 0x008ffaac
//画图里多了ecx:10的空间
//其实这两个动作就是在传参，只是我们感受不到而已
//这俩过会儿会用到
//接下来 call指令
//注意，我们要记住这个call指令里面的地址！
//图12
//这里进行F11 逐语句
// 一走，我们发现esp 的地址改为了0x008ffaa8 里面存放着的是00C21450
//是call指令下一步的地址
//这里我们的栈区有对方了一个地址 ： 是call指令的下一条指令的地址
//图13
//我们这个地址是为了返回来的时候还能够找得到我们的函数
//下一步再F11，才是我们真正的来到我们的ADD函数：start第二节
// 
//我们发现，前期函数内的工作还是为了我们的函数准备栈帧
//图14
//





#define CRT_SERCURE_NO_WARNINGS 1
#include<stdio.h>
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//函数栈帧的创建和销毁
//前期我们学习可能有很多的困惑：
//局部变量是怎么创建的？
//为什么局部比那辆的值是随机值？
//函数是怎么传参的，传参的顺序是怎么样的？
//形参和实参是什么关系？
//函数调用是怎么做的 ？
//函数调用结束后是怎么返回的？
//
//知道了函数栈帧的创建和销毁都毁了，其实就是修炼了自己的内功，也能够搞懂后期更多的知识。
//因为高级的编译器封装的比较多，不容易学习和观察，所以课件演示的时候使用的是VS2013
//在不同的编译器下，函数调用过程中栈帧的创建是略有差异的，具体细节取决于编译器的实现
//每一个版本是略有差异的，所以VS2019可能无法一比一实现课件所展示的画面
//所以就大量截图把
//
// 
// 介绍一下寄存器：
//eax
//ebx
// ecx
// edx
// 下面两个寄存器中存放的是地址：
// ebp 
// esp  
//这两个寄存器是用来维护函数栈帧的
//什么意思： 每一个函数调用，都要在栈区上开创建一个空间
//
//举个例子：
//开始编写函数了就
int add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	c = add(a, b);
	printf("%d", c);
	return 0;
}
//调用堆栈开始后，首先main函数被调用
// 
//我们通过观察发现，main函数首先被一个__tmainCERStartup()这个函数调用
//main函数也是被调用的（需要知道）
//
// 在VS2013中，main函数也是被其他函数调用的
//这个其他函数又是被mainCRTStarup()函数调用的
// 图3
//为什么要讲这些东西呢
//我们回到这个栈帧
//这个栈底指针和栈顶指针都是为了维护其中的地址，再次重复一下，我们下面开始研究
// 图1图2
//然后我们开始进行F10调试，在main函数入口停止进入 反汇编，观察汇编代码
//这些代码该如何理解呢？
//跟着思路来，符号名不好看，我们去掉符号名称
// 图4
//调用main函数之前我们要调用__CRTStarup() 它的栈帧应该提前创建好了
// 图5.0
//___CRTStarup 应该有两个指针（栈底指针和栈顶指针）指向这个空间，esp和ebp目前的位置就是在这两个地方
// 当我们从下往上走的时候，前提是下面是高地址  往上是低地址
// 图6.1
//我们首先push ebp     (压栈：给栈放个元素进去）
// 我们发现esp指针的地址跑到了ebp空间的最上方
// 
// 出栈：给栈顶删除一个元素，压栈：给栈顶放置一个元素
// 
//紧接着move操作，
//ebp指针到了esp指针的位置
//然后sub操作  减法操作（esp-04sh【8进制数字：228】）
//这里esp就变小了，指向了上面的区域
//esp往上走了
//那么我们ebp和esp又有了新的维护的空间
//我们为main函数申请好的好了空间，即main函数的栈帧（紫色部分）
//我们观察esp的地址，发现main函数的空间嘎嘎大
// 紧接着我们看见三个push操作
// 这三个值不用关心，他们会自动弹出的
// 分别是ebx esi edi,每当我们push完了之后esp指针就会变，它往上走
// 然后我们进行了一个lea操作 ：load effecive address 加载有效地址
// 把这样后面有效的地址加到edi里面去 ：FFFFFFF1Ch(显示符号名后：ebp-0E4h)
// word 表示两个字节
// dword 表示两倍 就是 四个字节
// 我们要把edi指针（指向的内存） 这个位置开始向下的这么多个空间进行ecx次（值为39h)全部改成eax的内容：0CCCCCCCH
// 图5图6
// ebp-0e4h就是 ：0x008ffac0这个位置
//初始化到哪里呢：ebp(0x008ffba4)
//刚刚这个动作，我们就把所有内存的值（main函数范围）全部改为了CCC
//图7
// 现在为main函数开辟内存的准备工作就结束了
//接下来就是有效代码： int a=10;
//dword ptr [ebp-8],0Ah
//图8
//我们的烫烫烫就是这些CCCC这样的东西
//int b=20;
//dword ptr[ebp-14h],14h
//b的20就放进去了，这个放的位置取决于编译器
//b的20就放进去了，这个放的位置取决于编译器
//b的20就放进去了，这个放的位置取决于编译器
// 这之间还空了4个字节，这个取决于编译器
//int c=0;
//dword ptr[ebp-20h],0
//接下来调用add函数
//图9 看看有效代码图片
//函数调用进行传递参数
// move eax,dword ptr [ebp-14h](b=20)
//push eax-20 (压栈） 
//压栈前 ：图10 esp：0x008ffab4
//压栈后：  图11 esp:0x008ffab0
// 画图里多出了eax：20的空间
//然后对a下手
// move ecx,dword ptr [ebp-8]
//push ecx 
// 压栈后  ：esp 0x008ffaac
//画图里多了ecx:10的空间
//其实这两个动作就是在传参，但是目前我们感受不到而已
//这俩过会儿会用到
//接下来 call指令
//注意，我们要记住这个call指令里面的地址！
//图12
//这里进行F11 逐语句开始call指令
// 一走，我们发现esp 的地址改为了0x008ffaa8 里面存放着的是00C21450
//是call指令下一步的左侧地址
//这里我们的栈区有对方了一个地址 ： 是call指令的下一条指令的地址
//图13
//我们这个地址是为了返回来的时候还能够找得到我们的函数
//下一步再F11
// 才是我们真正的来到我们的ADD函数：  start第二节
// 
//我们发现，前期函数内的工作还是为了我们的add函数准备栈帧
//图14
//图15
//图16
//move  ebs,esp   : ebp走到esp的位置，
//sub   esp，0CCh ： esp往上走
//这次的操作是再为add函数开辟栈帧
//图17
//然后常规的3次push ebx esi edi，esp常规的往上走
//然后常规的初始化空间
//lea		edi,[ebp+FFFFFF34h]
//mov		ecx,33h  （次数）
//mov		eax,0CCCCCCCCh   （初始化）内容
//rep stos  dowrd ptr es:[edi]
//图18
//然后是有效代码
//int z = 0;
//mov  dword ptr[ebp-8],0
//然后
//z=x+y;
//但是我们发现，我们根本没有在add函数内部创建x和y
// 不要急，我们看他的位置在哪里
//图19
// 图20
// 我们发现，这俩个位置都在ebp下方，既是在main函数内部
// 通过这两个位置进行计算，最后将结果放到ebp-8的位置当中
// 图21
// 我们函数在调用计算的时候，我们没有创建形参，而是传参的时候就传过去了
// 这两个参数的位置就在call指令的下一条指令地址的下方空间内
// 我们的形参根本不是在add函数内部调用的，而是直接传参的时候干过去了
//图22
//然后怎么返回呢
//结果我们已经算出来了，我们将算好的值赋给eax寄存器里面
//mov  eax,dowrd ptr [ebp-8]
// z会随着函数结束而销毁，我们将返回值放到eax寄存器进行保存，然后回到主函数
//然后三次  pop edi esi ebx
// 图23
// 我们将这3个寄存器弹出，那么esp的位置也会下降，反映在值的增加
// 图24
// 同样的，我们的add函数也不需要了，然后进行回收
// 一条指令就搞定了
// mov   esp,ebp  :把ebp赋值给esp 
// 图25
// ebp和esp都指向同一位置
// 然后 pop ebp
// 弹出ebp-main这个元素（值为最底层main函数最初的地址）
// 这个元素就是为了我们函数销毁后找到我们的main函数
// 这一下就把我们的ebp弹回了最初的main函数开头
// 图26
// 相应的pop完之后，esp也将向下移动一下，从ebp-main元素的上方到他的下方
// 也就是回到了main函数的栈帧空间 
//  然后是ret指令
//ret前一步的pop ebp,将ebp的位置弹回到了main函数的栈底，紧接着esp相应的向下移移动一下
//从ebp-main的上方走到了下方，那么esp ebp都回到了main函数的栈帧空间
//但是现在我们还在add函数内部，通过ret指令，弹到了我们的call指令的下一条指令的位置
//	这个ret，return返回指令就是从栈顶弹出了,回到了call指令的下一条指令
// 我们又回到了call指令下一条指令的位置：
// esp往下跳，跳过了call指令下一条指令的地址的栈帧空间
// 然后回到main函数操作了
// 图27
// add  esp,8
// 往下走了
// 下面存放着的是我们的形参，已经没有用了
// 跳过去，之后也意味着我们的空间还回给了操作系统
// 图28
// 然后
// mov   dword ptr [ebp-20h],eax
// 将返回值给了ebp-20h 给了变量c
// 返回值就是我们通过寄存器eax带回来的
// 
//这就是函数栈帧的创建和销毁
//
//我们回到最初的问题：
//局部变量是怎么创建的： 
//我们先为main函数创建好栈帧空间，然后我们再在初始化后的main函数空间内创建局部变量
// 
//为什么局部变量的值是随机值呢？
// 因为我们内存中初始化后的空间都是随机值，如果局部变量不初始化，那么里面就是随机值
// 对局部变量进行初始化，那么就是把那些随机值进行了覆盖
// 
// 函数是怎么传参的？传参的顺序是怎么样的？
// 当我们要调用的函数之前，按照从右向左的顺序，把我们的传递的参数我们就已push push 压栈进了栈帧空间
// 在add函数里通过指针偏移量找到了我们的形参，这就是传参以及他的使用
// 
// 形参和实参是什么关系？
// 值上是相同的，空间上是独立的，形参是实参的一份临时拷贝，改变形参不会影响实参
// 
// 函数调用是怎么做的？
// 已经讲清楚了
// 
//  函数调用是结束后怎么返回的？
// 调用之前我们就把call指令的下一条指令压进了栈帧空间里面
// 把ebp调用这个函数的上一个函数（main函数）的ebp地址也存进去了，通过函数里的pop弹出
// 就把上一个函数的ebp弹出了，返回到原先函数（main函数）的栈底进行维护
// 指针esp也就找到了栈顶 
// 我们又通过寄存器eax将返回值带回来从而完成函数调用结束后的返回
// 
// 
// 
// 同学的困惑：
// pop ebp就是把栈顶的元素弹出来放到ebp里面去，把值赋给ebp，就相当于把ebp的地址进行了改变 
// ebp就是存储函数栈帧里面栈底的地址
// 
// 寄存器是独立于内存的，是集成到CPU上的
// 硬盘
// 内存
// 寄存器
// 这些都完全独立
//  
//ebp和esp是存放地址的，是用来维护函数栈帧的
// 
// 
// 
// 
// 
// 
//















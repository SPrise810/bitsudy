#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//指针是内存中一个最小单元的编号，也就是地址
//平时我们口头所说的指针，通常指的是指针变量，是用来存放内存中地址的变量
//
//32位虚拟地址空间：
// CPU--创建32位地址--地址线传输--访问内存   32位（存放二进制序列）--4字节
//64位虚拟地址空间：
//CPU--创建64位地址--地址线传输--访问内存
//int main()
//{
//	int a = 10;// 
//	int* pa = &a;//pa是一个变量，专门用来存放地址的
//			//		这个变量就被称为 指针变量，俗称指针
//	//pa指针变量里面存放着a的第一个字节的地址（1字节）
//	return 0;
//}
//
//指针和指针类型
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	char ch = 'w';
//	char* pc = &ch;
//	printf("%d\n", sizeof(pa));
//	printf("%d\n", sizeof(pc));
//	//两者大小都为 4，但是我们仍然要加上 数据类型来创建指针变量 为什么？
//	return 0;
//}
//代码解释原因：
//int main()
//{
//	int a = 0x1122334;//16进制数字
//	//int* pa = &a;//修改成功，总共改变了4个字节的数据
//	//char* pa = &a；//只改变了一个字节的数据
//	*pa = 0;
//	//说明指针类型决定了  指针再解引用的时候，访问的权限（看待指针的方法）
//	//整型指针解引用访问4个字节
//	//字符指针解引用访问1个字节
//	return 0；
//}
//第二个用途：
//指针类型决定了指针 向前 向后，走的距离
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	char* pc = &a;
//	printf("%p\n", pa);//       00D5F790
//	printf("%p\n", pc);//		00D5F790
//	printf("%p\n", pa+1);//	    00D5F794  4字节
//	printf("%p\n", pc+1);//     00D5F791  1字节  
//	return 0;
//}
//
// sizeof(long)>=sizeof(int)
// 32位环境下 sizeof(long)-4 字节   sizeof(long)-8 字节
//
//访问的示例：
//int main()
//{
//	int arr[10] = { 0 };
//	//假设我们希望访问这四十个字节的时候，以字节为单位访问
//	//char* p=(char*)arr;//arr首元素地址
//	//int i = 0;
//	//for (i = 0; i < 40; i++)
//	//{
//	//	*p = 'x';
//	//	p++;
//	//}//这40个字节逐个修改
//	//
//	//如果希望以一个整型的形式访问
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 40; i++)
//	{
//		*p = 0x11223344;
//		p++;
//	}//4个字节为一组，逐个组修改
//
//	return 0;
//}
//
//课间休息小问题： 
// 
//不管是二维还是一维数组，再传参的时候，都不会去创建数组
//所以数组的大小不需要明确指定
//一维数组传参的时候，形参的数组大小可以省略
//二维数组传参的时候，形参的数组中，行可以省略（前提需要初始化），但是列不可以省略
//如果我们想用整型的指针变量指向一个浮点型
//
//float n = 3.14f;
//int* p = &n;
//*p = ;//???
//整型和浮点型的数据，在内存中存储的方式不同，*p的内容不确定
//
//野指针
// ： 是指针指向的位置是不可知的（随机的 不正确的  没有明确限制的)
//来源：  1/未初始化
//int main()
//{
//	int* p;//未进行初始化，存放的是随机值
//	int* p = NULL;//不知道的情况下就放个空的
//	int a = 10;//
//	int* p = &a;//已知要给哪个变量的情况下的正常初始化操作
//	*p = 20;
//	return 0;
//}
//来源2.指针越界访问
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int i = 0;
//	int* p = arr;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d\n", *p);//从‘5’之后就是野指针了
//		p++;
//	}
//	return 0;
//}
//
//来源3.指针指向的空间释放：
//int* test()
//{
//	int a = 10;
//	printf("%d", a);
//	return &a;
//}
//int main()
//{
//	int* p = test();//变量a 已经空间释放，a已销毁
//	*p = 100;//访问的内存有问题  
//	return 0;
//}
//如何避免野指针 ：
//1 . 认真 初始化
//	  不知道的话就=NULL；
//野指针就类似于我们生活中的野狗：
//野狗栓到树上就不会咬人了。NULL就是树
//2.小心指针越界
//3.指针指向的空间释放即放置NULL
//4.避免返回局部变量的地址
//5.指针使用之前检查有效性
//内存有一些空间是不给用户访问的， 内核使用（操作系统会讲)
//
// 指针运算
//
//1.指针+ - 整数
//2.指针 - 指针： 指针与指针之间元素的个数（大-小）
//3.指针的关系运算
//4.指针的关系运算
//int main()
// 
//2. 指针 - 指针
//2. 指针 - 指针
//2. 指针 - 指针
//2. 指针 - 指针
//2. 指针 - 指针
// 
//{
//	int arr[10] = { 0 };
//	printf("%d", &arr[9] - &arr[0]);//条件是 同一个 数组内容
//	return 0;
//}
//	//模拟实现mystrlen 计数器写法
//	//2.递归版本
//	//3.指针版本
//int my_strlen(char* arr)
//{
//	//a b c d e f \0 只要我们通过 \0   首元素的地址：就能够得到所有元素的个数
//	char* start = arr;
//	while (*arr)
//	{
//		arr++;
//	}
//	return arr - start;
//}
//int main()
//{
//	char arr[] = "abcdef";
//	printf("%d", my_strlen(arr));
//	return 0;
//}
//44444444扣一波4 表示我能够理解
//
//
// 4指针的关系运算
//
//int main()
//{
//	int* vp = NULL;
//	int a[5] = { 0 };
//	for (vp = &a[5]; vp > &a[0];)
//	{
//		*--vp = 0;
//	}
//	for (vp = &a[4]; vp >= &a[0]; vp--)
//	{
//		*vp = 0;
//	}
//	//实际再绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免这样写
//	//因为标准但是并不保证它一定可行
//	//标准规定：
//	//允许 指向数组元素的指针 与 指向数组最后一个元素后面的那个内存位置的指针比较
//	//但是不允许与指向第一个元素之前的那个内存位置的指针进行比较
// 
//	浅浅解释一下吧： 就是我们的指针可以 在最后一个元素‘越界’ ： 向后越界然后进行比较或是运算
//   但是我们不能在第一个元素的前面越界 进行比较或是运算
// 
// 	return 0;
//}
//
// 
//指针和数组
//
//数组名  数组首元素的地址
//两个例外：
//sizeof(数组名），数组名表示整个数组，计算的是整个数组的大小
//&数组名，数组名表示整个数组，取出的是整个数组的地址
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	//printf("%p\n", arr);//%p地址
//	//printf("%p\n", &arr[0]);
//	//两者一模一样
//	//数组名难道真的是首元素地址么？
//	//两个例外：
//	//sizeof(数组名），数组名表示整个数组，计算的是整个数组的大小
//	//&数组名，数组名表示整个数组，取出的是整个数组的地址
//	//
//	//数组是连续存放的，数组名代表首元素的地址，这样就可以进行访问啦
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	return 0;
//}
// 
//数组和指针不是一回事儿
//指针是存放地址的变量
//数组是一块连续的空间
//可以通过指针来访问数组
//
//二级指针
//
//指针的指针
// 同样还有三级指针，反正套就完了哈哈哈哈哈哈哈哈哈哈哈哈 
//int main()
//{
//	int a = 10;//int 
//	int* pa = &a;//pa指针变量  类型int*   *:pa是指针变量  int:pa指向的是int类型数据
//	int** ppa = &pa;//ppa 为二级指针，后面的* 告诉我们ppa是指针 前面的 int* :ppa指向的对象是int*的
//	//*ppa-->pa
//	//*pa-->a
//	//**ppa-->a
//	return 0;
//}
//
//指针数组 - 存放指针的数组；
//整型数组 - 
//int main()
//{
//	int arr[5];
//	char ch[6];
//	int a = 10;
//	int b = 11;
//	int c = 12;
//	int d = 13;
//	int e = 14;
//	int* arr2[5] = { &a,&b,&c,&d,&e };//指针数组
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		
//		printf("%d", *arr2[i]);
//	}
//	return 0;
//}
//
//模拟二维数组
//
int main()
{
	int data1[] = { 1,2,3,4,5 };
	int data2[] = { 1,2,3,4,5 };
	int data3[] = { 1,2,3,4,5 };
	int data4[] = { 1,2,3,4,5 };
	//arr就是一个指针数组
	int* arr[4] = { data1,data2,data3,data4 };//内存布局发生改变
	//arr
	//   data1-->1 2 3 4 5(data1)
	//   data2...
	//   ...
	int i = 0;
	//初步介绍啊，不用着急
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			//printf("%d ",arr[i][j]);
			printf("%d ",*(arr[i]+j));//一样的
		}
		printf("\n");
	}
	return 0;
  }
